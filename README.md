# Проект Push_swap

## Введение
Push_swap — это алгоритмический проект в рамках обучающей программы [Школы 42](https://42.fr/en/learn-everything-about/) (в моем случае - это [42london.com](https://42london.com/)), направленный на сортировку данных с использованием ограниченного набора инструкций с двумя стеками. Цель — отсортировать данные в стеке A с минимальным количеством операций, используя вспомогательный стек B.

## Описание Алгоритма сортировки
### Общий принцип
Алгоритм основан на концепции двух стеков (A и B) и использовании серии операций для перемещения элементов между стеками, чтобы достичь отсортированного состояния стека A.

Часть обязательных требований:
- У вас есть два стека, названные a и b.
- В начале:
  - Стек a содержит случайное количество отрицательных и/или положительных чисел, которые не могут повторяться.
  - Стек b пуст.
- Цель состоит в том, чтобы отсортировать числа в стеке a в порядке возрастания. Для этого у вас есть следующие операции:
  - sa (swap a): Поменять местами первые 2 элемента на вершине стека a. Ничего не делать, если есть только один элемент или их нет.
  - sb (swap b): Поменять местами первые 2 элемента на вершине стека b. Ничего не делать, если есть только один элемент или их нет.
  - ss: sa и sb одновременно.
  - pa (push a): Взять первый элемент на вершине b и поместить его на вершину a. Ничего не делать, если b пуст.
  - pb (push b): Взять первый элемент на вершине a и поместить его на вершину b. Ничего не делать, если a пуст.
  - ra (rotate a): Сдвинуть все элементы стека a на 1 вверх. Первый элемент становится последним.
  - rb (rotate b): Сдвинуть все элементы стека b на 1 вверх. Первый элемент становится последним.
  - rr: ra и rb одновременно.
  - rra (reverse rotate a): Сдвинуть все элементы стека a на 1 вниз. Последний элемент становится первым.
  - rrb (reverse rotate b): Сдвинуть все элементы стека b на 1 вниз. Последний элемент становится первым.
  - rrr: rra и rrb одновременно.

В проекте Push_swap реализованы две ключевые стратегии сортировки: для малых наборов данных используется tiny_sort, а для больших — Radix Sort с побитовым сравнением.

Для записи и вывода команд сортировки в моём проекте Push Swap используется файловый дескриптор. Команды сортировки записываются в текстовый файл с помощью файлового дескриптора, открытого для записи. Затем, с помощью функции `get_next_line`, команды последовательно считываются из файла и выводятся на стандартный вывод, позволяя пользователю видеть последовательность действий, необходимых для сортировки стека.

Библиотека libft используется для предоставления различных утилитарных функций, таких как `ft_split`, `ft_atoi`, `ft_strjoin` и т.п., которые необходимы для обработки входных данных, работы со строками, списками и т.п.. Использование собственной библиотеки упрощает код, делая его более читаемым и легко поддерживаемым, а также обеспечивает переиспользование кода в различных частях проекта.

### Сортировка побитовым сравнением
Для больших наборов данных используется алгоритм побитовой сортировки Radix Sort. Этот метод включает в себя сравнение битовых представлений индексов элементов. 

Алгоритм последовательно рассматривает каждый бит числа, начиная с младших битов (самый правый бит). Элементы перекладываются между стеками A и B в зависимости от значения текущего рассматриваемого бита. Этот процесс повторяется для каждого бита, что в конечном итоге приводит к отсортированному стеку A.

#### Побитовое Сравнение:
При рассмотрении каждого бита чисел происходит их разделение на две группы в зависимости от значения этого бита: если бит установлен в 1, элемент остается в стеке A; если бит равен 0, элемент перемещается в стек B. После прохода по всем битам все элементы из стека B возвращаются в стек A, сохраняя отсортированный порядок.

Алгоритм поразрядной сортировки (radix sort) по своей сути оптимизирован для работы с неотрицательными числами, так как он основан на последовательном сравнении битов числа начиная с наименее значимого (LSB) и движении к наиболее значимому (MSB). Это связано с тем, что в двоичном представлении отрицательные числа кодируются по-другому (например, с использованием дополнительного кода), и их прямое сравнение по битам без учета знака может привести к некорректным результатам сортировки.
Использование индексации элементов вместо их реальных числовых значений позволяет обойти эту проблему, так как индексация преобразует исходный набор данных в последовательность неотрицательных целых чисел, начиная с 0. Таким образом, каждому элементу стека, независимо от его исходного числового значения (будь то положительное или отрицательное число), присваивается уникальный неотрицательный индекс, который отражает его относительное положение в упорядоченном наборе.

Этот подход обладает несколькими преимуществами:
- **Универсальность:** Алгоритм становится пригодным для работы с любыми целыми числами, включая отрицательные.
- **Сохранение относительного порядка:** Индексы помогают сохранить относительный порядок элементов, что особенно важно для стабильности сортировки.
- **Простота и понятность:** Преобразование исходных данных в индексы упрощает логику алгоритма и делает его более понятным и предсказуемым в различных ситуациях.

Таким образом, использование индексов вместо реальных числовых значений в алгоритме поразрядной сортировки с побитовым сравнением позволяет эффективно и корректно сортировать стеки, содержащие как положительные, так и отрицательные числа.
## Пример работы работы алгоритма сортировки radix, который я использовал в данном проекте 
Давайте рассмотрим пример побитового сравнения на стеке из 6 чисел: 2, 3, 4, 5, 6, 7. Для наглядности представим их в двоичном формате:

2: 00010
3: 00011
4: 00100
5: 00101
6: 00110
7: 00111

Предположим, мы хотим отсортировать эти числа с помощью побитовой сортировки. Для этого мы проведем несколько итераций, в каждой из которых будем сравнивать определенный бит каждого числа, начиная с самого младшего (справа).

Итерация 1 (самый младший бит):

Числа с 0 в этом бите (четные): 2 (00010), 4 (00100), 6 (00110)
Числа с 1 в этом бите (нечетные): 3 (00011), 5 (00101), 7 (00111)
Итерация 2 (второй младший бит или второй по значимости бит с конца):

В этой итерации разделяем группы чисел на основе второго бита. Например, среди четных чисел 4 (00100) и 6 (00110) имеют 1 во втором бите, а 2 (00010) - нет. Среди нечетных чисел 5 (00101) и 7 (00111) имеют 1, а 3 (00011) - нет.
Процесс продолжается для каждого бита, пока не будет достигнута полная сортировка стека. В каждой итерации числа могут перекладываться между двумя стеками (например, a и b в контексте вашего проекта) на основе значения текущего рассматриваемого бита.

Этот метод эффективно использует побитовые операции для сортировки чисел по их двоичным представлениям, обеспечивая при этом линейную сложность времени исполнения в среднем случае для равномерно распределенных данных.

### Tiny Sort
Для очень маленьких наборов данных (до 5 элементов) используется специализированный алгоритм сортировки, который напрямую сортирует элементы в стеке A с помощью минимального количества операций. Основывается на простых операциях со стеком, таких как swap (обмен местами двух верхних элементов), rotate (сдвиг всех элементов вверх) и reverse rotate (сдвиг всех элементов вниз), чтобы минимизировать количество операций и достигнуть отсортированного состояния.

## Бонусная Часть - checker
В бонусной части реализована программа `checker`, которая проверяет, правильно ли отсортированы элементы стека A после выполнения последовательности допустимых проектом операций со стеками, либо можно проверить предоставленные программой push_swap команды. Чекер использует файловый дескриптор для считывания команд из стандартного ввода. Пользователь вводит команды через терминал, а чекер считывает их по одной (Enter или \n) до момента как достигнет конца файла (Ctrl + D или EOF), проверяет корректность выполнения каждой команды на стеках, и в конце выводит результат проверки (OK или KO), используя стандартный вывод.

Чекер позволяет проверить корректность работы программы push_swap, сравнивая исходное состояние стека и результат выполнения команд, сгенерированных push_swap. Для этого можно использовать конвейер (pipeline) в bash (оператор pipe |), который передает вывод одной программы на вход другой, позволяя легко проверить результаты выполнения push_swap с помощью checker.

Например:

```bash
./push_swap 4 67 3 87 23 | ./checker 4 67 3 87 23
```

Эта команда сначала выполняет push_swap с заданными числами, результат работы (команды сортировки) передаётся через pipe "|" программе checker, которая проверяет, приведут ли эти команды к отсортированному стеку. Если стек отсортирован правильно, checker выведет OK, иначе — KO.

## Обработка Ошибок
Проект включает проверки на валидность входных данных, включая проверку на дубликаты, проверку диапазона значений и проверку наличия только числовых аргументов.
