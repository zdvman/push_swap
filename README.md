# Проект Push_swap

## Введение
Push_swap — это алгоритмический проект, направленный на сортировку данных с использованием ограниченного набора инструкций с двумя стеками. Цель — отсортировать данные в стеке A с минимальным количеством операций, используя вспомогательный стек B.

## Описание Алгоритма
### Общий принцип
Алгоритм основан на концепции двух стеков (A и B) и использовании серии операций для перемещения элементов между стеками, чтобы достичь отсортированного состояния стека A.

Часть обязательных требований:
- У вас есть два стека, названные a и b.
- В начале:
  - Стек a содержит случайное количество отрицательных и/или положительных чисел, которые не могут повторяться.
  - Стек b пуст.
- Цель состоит в том, чтобы отсортировать числа в стеке a в порядке возрастания. Для этого у вас есть следующие операции:
  - sa (swap a): Поменять местами первые 2 элемента на вершине стека a. Ничего не делать, если есть только один элемент или их нет.
  - sb (swap b): Поменять местами первые 2 элемента на вершине стека b. Ничего не делать, если есть только один элемент или их нет.
  - ss: sa и sb одновременно.
  - pa (push a): Взять первый элемент на вершине b и поместить его на вершину a. Ничего не делать, если b пуст.
  - pb (push b): Взять первый элемент на вершине a и поместить его на вершину b. Ничего не делать, если a пуст.
  - ra (rotate a): Сдвинуть все элементы стека a на 1 вверх. Первый элемент становится последним.
  - rb (rotate b): Сдвинуть все элементы стека b на 1 вверх. Первый элемент становится последним.
  - rr: ra и rb одновременно.
  - rra (reverse rotate a): Сдвинуть все элементы стека a на 1 вниз. Последний элемент становится первым.
  - rrb (reverse rotate b): Сдвинуть все элементы стека b на 1 вниз. Последний элемент становится первым.
  - rrr: rra и rrb одновременно.

### Сортировка побитовым сравнением
Для больших наборов данных используется алгоритм побитовой сортировки radix sort. Этот метод включает в себя сравнение битовых представлений индексов элементов и их последовательное распределение между стеками для достижения отсортированного состояния.

Алгоритм поразрядной сортировки (radix sort) по своей сути оптимизирован для работы с неотрицательными числами, так как он основан на последовательном сравнении битов числа начиная с наименее значимого (LSB) и движении к наиболее значимому (MSB). Это связано с тем, что в двоичном представлении отрицательные числа кодируются по-другому (например, с использованием дополнительного кода), и их прямое сравнение по битам без учета знака может привести к некорректным результатам сортировки.
Использование индексации элементов вместо их реальных числовых значений позволяет обойти эту проблему, так как индексация преобразует исходный набор данных в последовательность неотрицательных целых чисел, начиная с 0. Таким образом, каждому элементу стека, независимо от его исходного числового значения (будь то положительное или отрицательное число), присваивается уникальный неотрицательный индекс, который отражает его относительное положение в упорядоченном наборе.

Этот подход обладает несколькими преимуществами:
- **Универсальность:** Алгоритм становится пригодным для работы с любыми целыми числами, включая отрицательные.
- **Сохранение относительного порядка:** Индексы помогают сохранить относительный порядок элементов, что особенно важно для стабильности сортировки.
- **Простота и понятность:** Преобразование исходных данных в индексы упрощает логику алгоритма и делает его более понятным и предсказуемым в различных ситуациях.

Таким образом, использование индексов вместо реальных числовых значений в алгоритме поразрядной сортировки с побитовым сравнением позволяет эффективно и корректно сортировать стеки, содержащие как положительные, так и отрицательные числа.

### Tiny Sort
Для очень маленьких наборов данных (до 5 элементов) используется специализированный алгоритм сортировки, который напрямую сортирует элементы в стеке A с помощью минимального количества операций.

## Бонусная Часть
В бонусной части реализована программа `checker`, которая проверяет, правильно ли отсортированы элементы стека A после выполнения последовательности допустимых проектом операций со стеками, либо можно проверить предоставленные программой push_swap команды.

## Обработка Ошибок
Проект включает проверки на валидность входных данных, включая проверку на дубликаты, проверку диапазона значений и проверку наличия только числовых аргументов.

## Пример работы работы алгоритма сортировки radix, который я использовал в данном проекте 
Давайте рассмотрим пример побитового сравнения на стеке из 6 чисел: 2, 3, 4, 5, 6, 7. Для наглядности представим их в двоичном формате:

2: 00010
3: 00011
4: 00100
5: 00101
6: 00110
7: 00111
Предположим, мы хотим отсортировать эти числа с помощью побитовой сортировки. Для этого мы проведем несколько итераций, в каждой из которых будем сравнивать определенный бит каждого числа, начиная с самого младшего (справа).

Итерация 1 (самый младший бит):

Числа с 0 в этом бите (четные): 2 (00010), 4 (00100), 6 (00110)
Числа с 1 в этом бите (нечетные): 3 (00011), 5 (00101), 7 (00111)
Итерация 2 (второй по младшости бит):

В этой итерации разделяем группы чисел на основе второго бита. Например, среди четных чисел 4 (00100) и 6 (00110) имеют 1 во втором бите, а 2 (00010) - нет. Среди нечетных чисел 5 (00101) и 7 (00111) имеют 1, а 3 (00011) - нет.
Процесс продолжается для каждого бита, пока не будет достигнута полная сортировка стека. В каждой итерации числа могут перекладываться между двумя стеками (например, a и b в контексте вашего проекта) на основе значения текущего рассматриваемого бита.

Этот метод эффективно использует побитовые операции для сортировки чисел по их двоичным представлениям, обеспечивая при этом линейную сложность времени исполнения в среднем случае для равномерно распределенных данных.

## Заключение
